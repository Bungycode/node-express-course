1. In this lesson, you created a middleware function called asyncWrapper. Why?
  I created a middleware function called asyncWrapper so I could refactor my controllers without having to repeatedly use the try/catch block for my asynchronus operations. Instead, I can just write the logic for the controller and if an error occurs, the catch block in my asyncWrapper function will catch it and handle it from there.

2. Suppose that you want to make sure that both a status code and and error message are send back to the user when they request the URL for a task that does not exist. Assume that youâ€™ve created a CustomAPIError class and an error handler that references that class. Complete the code:

const getTask = asyncWrapper(async (req, res, next) => {
  const { id: taskID } = req.params;
  const task = await Task.findOne({ _id: taskID });
  if (!task) {
    // your code here
    return next(createCustomError(`No task with id of ${taskID}`, 404))
  }
  res.status(200).json({ task });
});